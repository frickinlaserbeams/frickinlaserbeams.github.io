<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Frickin Laser Beams]]></title>
  <link href="frickinlaserbeams.co/atom.xml" rel="self"/>
  <link href="frickinlaserbeams.co/"/>
  <updated>2014-11-09T00:22:21+00:00</updated>
  <id>frickinlaserbeams.co/</id>
  <author>
    <name><![CDATA[Frickin Laser Beams]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Reversing C++ - Part 2 Copy Constructors, Destructors and Assignment Operators]]></title>
    <link href="frickinlaserbeams.co/blog/2014/11/08/reversing-c-plus-plus-part-2-copy-constructors-destructors-and-assignment-operators/"/>
    <updated>2014-11-08T22:33:55+00:00</updated>
    <id>frickinlaserbeams.co/blog/2014/11/08/reversing-c-plus-plus-part-2-copy-constructors-destructors-and-assignment-operators</id>
    <content type="html"><![CDATA[<p>Welcome to part 2 of this series on basic C++ reversing with IDA.</p>

<p>In <a href="frickinlaserbeams.co/blog/2014/10/10/reversing-c-plus-plus-part-1-basic-construction/">part 1</a> we looked at basic object construction. In this post we will take a brief look at copy constructors, destructors and assignment operators, before moving onto inheritance and virtual methods in part 3.</p>

<p>Lets start by looking at the previous example where we saw no copy constructor, destructor or assignment operator:</p>

<p><img src="frickinlaserbeams.co/images/reversing/part-1-5.png"></p>

<p>It&rsquo;s fairly obvious why we don&rsquo;t see a copy constructor or assignment operator as we haven&rsquo;t defined them ourselves and the compiler hasn&rsquo;t needed to define default versions for us as we&rsquo;ve not carried out any copying or assignment. What should happen though, is implicit destruction of our object as it goes out of scope. So why don&rsquo;t we see any object destruction? Why hasn&rsquo;t the compiler generated a default constructor? The reason is that all of the member variables are primative types. As primitage types do not require a destructor, neither does out class. If, however, we were to add a new member variable that did require destruction then a default destructor would be generated.</p>

<p>Let&rsquo;s prompt the compiler to generate a default copy constructor, destructor and assignment operator with the following code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;string&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">TestClass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">TestClass</span><span class="p">()</span><span class="o">:</span>
</span><span class='line'>        <span class="n">mStringA</span><span class="p">(),</span>
</span><span class='line'>        <span class="n">mValueA</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
</span><span class='line'>        <span class="n">mValueB</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">mStringA</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">mValueA</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">mValueB</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">TestClass</span><span class="o">*</span> <span class="n">testClassA</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestClass</span><span class="p">;</span>
</span><span class='line'>    <span class="n">TestClass</span> <span class="n">testClassB</span> <span class="o">=</span> <span class="o">*</span><span class="n">testClassA</span><span class="p">;</span>
</span><span class='line'>    <span class="o">*</span><span class="n">testClassA</span> <span class="o">=</span> <span class="n">testClassB</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">delete</span> <span class="n">testClassA</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>If we open the resulting stripped binary (see <a href="frickinlaserbeams.co/blog/2014/10/10/reversing-c-plus-plus-part-1-basic-construction/">previous post</a>) the decompiler produces the following:</p>

<p><img src="frickinlaserbeams.co/images/reversing/part-2-1.png"></p>

<p>Here we see the main function (<code>sub_80486FC()</code>) followed by the constructor (<code>sub_80487A6()</code>), copy constructor (<code>sub_80497CE()</code>), assignment operator (<code>sub_8048814()</code>) and destructor (<code>sub_8048800()</code>). Note that we have one object created on the heap with the <code>new()</code> operator and that the compiler adds a check on line 14 of <code>main()</code> to ensure that the object is valid before calling the destructor and delete operators.</p>

<p>Following the addition of further type information and some renaming as described in <a href="frickinlaserbeams.co/blog/2014/10/10/reversing-c-plus-plus-part-1-basic-construction/">part 1</a> we can come up with something more readable (we don&rsquo;t define the string type, but the offsets of the remaining variables tell us that it&rsquo;s the size of the dword, so we set it as such in the structure definition). In addition to the steps described in <a href="frickinlaserbeams.co/blog/2014/10/10/reversing-c-plus-plus-part-1-basic-construction/">part 1</a> we can remove the temporary valiables from the decompiler output by right clicking the variable and selecting <code>Map to another variable =</code>, resulting the in the following (to rename the destructor using the <code>~</code> character you may also need to upaate the <code>NameChars</code> variable in the <code>ida.cfg</code> configuration file):</p>

<p><img src="frickinlaserbeams.co/images/reversing/part-2-2.png"></p>

<p>Adding custom copy constructors, destructors and assignment operators has no additional affect on the compilation or output from IDA other than the changes to the respective implementations.</p>

<p>In the next installment we will look at inheritance and virtual functions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reversing C++ - Part 1 Basic Construction]]></title>
    <link href="frickinlaserbeams.co/blog/2014/10/10/reversing-c-plus-plus-part-1-basic-construction/"/>
    <updated>2014-10-10T23:27:26+01:00</updated>
    <id>frickinlaserbeams.co/blog/2014/10/10/reversing-c-plus-plus-part-1-basic-construction</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been developing applications in C++ for around 10 years but now find myself on the opposite end; reversing them. With some previous experience reversing C code, I can attest that C++ is an entirely different beast and brings an entirely new set of challenges.</p>

<p>To help build some experience of reversing C++ and to re-enforce my understanding of C++ compilation, I&rsquo;ve been doing some exercises to see how different C++ constructs appear following disassembly and decompilation in <a href="http://www.hex-rays.com/products/ida">IDA</a>. This series of posts covers these exercises and hopefully provides some benefit to others who may be interested in this topic.</p>

<p>Note that I&rsquo;m using IDA with the <a href="http://www.hex-rays.com/products/decompiler/index.shtml">Hex-Rays Decompiler</a> for these examples. If you don&rsquo;t already have a copy of IDA, you can get an evaluation copy of IDA from the <a href="http://www.hex-rays.com">Hex-Rays website</a> (or use the free version), but you&rsquo;ll have to purchase the decompiler as no evaluation is offered.</p>

<p>So to start with, let&rsquo;s look at basic object construction with the following example code:</p>

<figure class='code'><figcaption><span>Basic Construction Example</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">class</span> <span class="nc">TestClass</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">TestClass</span><span class="p">()</span><span class="o">:</span>
</span><span class='line'>        <span class="n">mValueA</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="n">mValueB</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">mValueA</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">mValueB</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">TestClass</span> <span class="n">testClassA</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Working on a 32-bit Linux box I compile and strip the binary as shown below. Note that we strip the binary with the assumption that &lsquo;real&rsquo; applications will also have their symbols stripped.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>g++ basicConstructionExample.cpp -o basicConstructionExample
</span><span class='line'><span class="nv">$ </span>strip -s basicContructionExample
</span></code></pre></td></tr></table></div></figure>


<p>If we now open the resulting binary in IDA and hit F5 we see that our code look something like this:</p>

<p><img src="frickinlaserbeams.co/images/reversing/part-1-4.png"></p>

<p>The output from the decompiler is pretty good, but not quite what we see in the original source code.</p>

<ol>
<li>The function and variable names are incorrect.</li>
<li>The <code>TestClass</code> object has been identified as an <code>int</code> type in both the <code>main</code> function and the <code>TestClass</code> constructor.</li>
<li>The function signature of the <code>TestClass</code> constructor has been identified as returning an <code>int</code> value rather than having a <code>void</code> return type.</li>
<li>Declaration of the <code>TestClass</code> object is separate from construction of the object.</li>
</ol>


<p>Some of these differences we would expect, such as the missing function names (we stipped all these) and the fact that object declaration and initialisation are separate. However, this is not something which we see explicitly when developing the code in the first place. Luckily, IDA provides us with tools that we can use to fix up some of these differences and bring the code back to resembling what we would see when developing it.</p>

<p>Firstly, we can update the function and variable names to something more readable, by simply highlighting the existing name in the listing and hitting <code>n</code>.</p>

<p>Next, we can address the <code>TestClass</code> type. Binaries do not contain explicit data on how structures and classes are composed, so it&rsquo;s no surprise that IDA doesn&rsquo;t provide us with this information either. As such, we need to tell IDA about the composition of the class ourselves. This we can do using the &lsquo;Structures&rsquo; subview which can be accessed from the &lsquo;View&rsquo; menu.</p>

<p><img src="frickinlaserbeams.co/images/reversing/part-1-1.png"></p>

<p>From here we can create a new structure by pressing <code>Insert</code> (<code>i</code> on OSX) from within the &lsquo;Structures&rsquo; view. As we already know the name or our structure we can go ahead an name it TestClass, but when reversing unknown structures it may be wise to leave renaming of the structure until it&rsquo;s purpose is known.</p>

<p>Once the structure is created, we can add new members to the with the <code>d</code> (data), <code>a</code> (ascii) or <code>*</code> (array) keys. As shown in the constructor, code our class contains two dword members, one at <code>*a1</code> and another at <code>*(a1 + 4)</code>, so we can go ahead and add two <code>dd</code> (dword) members and rename them with <code>n</code>. Here&rsquo;s the finished product:</p>

<p><img src="frickinlaserbeams.co/images/reversing/part-1-2.png"></p>

<p>Now that we have our class structure defined, we can update the references in the decompiler output with the correct types by highlighting the variable, right clicking, selecting &lsquo;Convert to struct &rsquo; and then &lsquo;TestClass&rsquo; from the list in the subsequent pop-up box:</p>

<p><img src="frickinlaserbeams.co/images/reversing/part-1-3.png"></p>

<p>Note that the value <code>v0</code> in <code>main</code> is not actually a pointer, so we can change this to a <code>TestClass</code> instance manually by right clicking on the variable, selecting &lsquo;Set lval type&rsquo; and providing the correct type.</p>

<p>The final step is to change the return type of the construtor, which can be acheived by highlighting the function name and hitting <code>Y</code>.</p>

<p>With all these changes made, the final output view looks much more familiar:</p>

<p><img src="frickinlaserbeams.co/images/reversing/part-1-5.png"></p>

<p>One thing we haven&rsquo;t covered here is the creation of objects on the heap. Actually, the output from the decompiler is exactly the same, bar the use of <code>operator new</code> for the allocation of the memory on the heap (plus the fact that <code>v0</code> is a pointer as identified by the use of <code>operator new</code>) and the use of <code>operator delete</code> for de-allocation.</p>

<p><img src="frickinlaserbeams.co/images/reversing/part-1-6.png"></p>

<p>That&rsquo;s pretty much it for basic object construction. In the next part we&rsquo;ll take a look at copy constructors, destructors and assignment operators.</p>
]]></content>
  </entry>
  
</feed>
